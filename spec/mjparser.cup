package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

//Keywords
terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH;

//Special Characters
terminal LBRACE, RBRACE, SEMI, LPAREN, RPAREN, LSQUAREBR, RSQUAREBR;

//Operators
terminal PLUS, MINUS, STAR, FWDSLASH, PERC, DBLEQ, EXLEQ, GRT, GRTEQ, LSS, LSSEQ, DBLAMP, DBLVER, COMMA, EQUAL, DBLPLUS, DBLMINUS;

//Value Tokens
terminal Integer NUMBER;
terminal String IDENT;
terminal Boolean BOOL;
terminal Character CHAR;

//TODO: organize categories better
//Objects
nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName;
nonterminal GlobalDecl, ConstDecl, VarDecl, ClassDecl, VarIdent, FormalParamDecl;


//Lists
nonterminal GlobalDeclList, MethodDeclList, ConstDeclList, VarDeclInnerList, VarDeclList;
nonterminal StatementList, FormalParamList, DesignatorList, ActualParamList;
nonterminal ExprInner;

//Types and calculations
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, Condition, CondTerm, CondFact;

//Operations
nonterminal Relop, Addop, Mulop;
nonterminal ConstIdentValue;

//Options
nonterminal Inheritance, FormPars, ActualPars;

//Statements
nonterminal Statement, DesignatorStatement, ConditionStatements;

//Precedences
precedence left ELSE;

//GRAMMAR
Program ::= (Program) PROG ProgName:p GlobalDeclList LBRACE MethodDeclList RBRACE 
;

ProgName ::= (ProgName) IDENT:pName 
;

GlobalDeclList ::= (GlobalDeclarations) GlobalDeclList GlobalDecl
				| (NoGlobalDecl) /* epsilon */
;

GlobalDecl ::= (GlobalConstDeclaration) ConstDecl 
				| (GlobalVarDeclaration) VarDecl
				| (GlobalClassDeclaration) ClassDecl
				;
				
ConstDecl ::= (ConstDecl) CONST Type:constType ConstDeclList SEMI
				;
				
Type ::= (Type) IDENT:typeName 
;
				
ConstDeclList ::= (ConstDecls) ConstDeclList COMMA ConstIdentValue
				| (SingleConstDecl) ConstIdentValue
				;
				
ConstIdentValue ::= (IntConstIdentValue) IDENT:cName EQUAL NUMBER:numValue
				| (BoolConstIdentValue) IDENT:cName EQUAL BOOL:boolValue
				| (CharConstIdentValue) IDENT:cName EQUAL CHAR:charValue
				;
				
VarDecl ::= (VarDecl) Type:varType VarDeclInnerList SEMI
				;
				
VarDeclInnerList ::= (VarDeclInnerList) VarDeclInnerList COMMA VarIdent
				| (SingleVarDecl) VarIdent
				;
				
VarIdent ::= (VarSingle) IDENT:vName
				| (VarArray) IDENT:vName LSQUAREBR RSQUAREBR
				;

VarDeclList ::= (VarDeclList) VarDeclList VarDecl
				| (NoVarDecl) /*epsilon*/
				;
				
ClassDecl ::= (ClassDecl) CLASS IDENT:clNAME Inheritance LBRACE VarDeclList RBRACE LBRACE MethodDeclList RBRACE
				;

Inheritance ::= (Extends) EXTENDS Type:parent 
				| /*epsilon*/
				;
				
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				| (NoMethodDecl)/* epsilon */
				;

MethodDecl ::= (MethodDecl) MethodTypeName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE 
			   	;

MethodTypeName ::= (MethodTypeName) Type:retType IDENT:methName
				;

FormPars ::= (FormParams) FormalParamList 
				| (NoFormParam) /* epsilon */ 
				;

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
				| (SingleFormalParamDecl) FormalParamDecl
				;
					
FormalParamDecl ::= (FormalParamDecl) Type IDENT 
				;

StatementList ::= (Statements) StatementList Statement 
				| (StatementsBrackets) LBRACE StatementList Statement RBRACE
				| (NoStmt) /* epsilon */
				;	
				  
Statement ::= (DesignatorStmt) DesignatorStatement SEMI 
			  |
			  (IfStmt) IF LPAREN Condition RPAREN ConditionStatements   
			  |
			  (IfElseStmt) IF LPAREN Condition RPAREN ConditionStatements ELSE ConditionStatements
			  |
			  (WhileStmt) WHILE LPAREN Condition RPAREN ConditionStatements 
			  |
			  (BreakStmt) BREAK SEMI
			  |
			  (ContinueStmt) CONTINUE SEMI
			  |
			  (ReturnStmt) RETURN Expr:t SEMI
			  |
			  (BlankReturnStmt) RETURN SEMI
			  | 
			  (ReadStmt) READ LPAREN Designator RPAREN SEMI
			  |
			  (PrintStmt) PRINT LPAREN Expr RPAREN SEMI
			  | 
			  ;

ConditionStatements ::= (CndSingleStmt) Statement
			  	| (CndMultipleStmts) LBRACE StatementList RBRACE
				| (CndNOStmts) SEMI 
			  	;

//TODO: arrays
//TODO: error recovery
//TODO: function call
DesignatorStatement ::= (Assignment) Designator:dest EQUAL Expr:e
				| (Increment) Designator:dest DBLPLUS
				| (Decrement) Designator:dest DBLMINUS
				| (MultiAssignment) LSQUAREBR DesignatorList RSQUAREBR EQUAL Designator
				| (FuncCall) Designator:dest LPAREN ActualPars RPAREN
				;

Designator ::= (Designator) IDENT:name
				;

DesignatorList ::= (SingleDesignator) Designator
				| (MultiDesignator) DesignatorList COMMA Designator
				; 

Condition ::= (CondSingleTerm) CondTerm
				| (CondMultiTerms) Condition DBLVER CondTerm
				;

CondTerm ::= (CondTermSingleFact) CondFact
				| (CondTermMultiFacts) CondTerm DBLAMP CondFact
				;
				
//TODO: convert expressions to bool?				
CondFact ::= (CondFactSingleExpr) Expr 
				| (CondFactMultiExpr) CondFact Relop Expr
			  	;
			  	
Relop ::= (Equals) DBLEQ
				| (NotEquals) EXLEQ
				| (Greater) GRT
				| (GreaterEquals) GRTEQ
				| (Less) LSS
				| (LessEquals) LSSEQ
				;
		
Expr ::= (NegativeExpr) MINUS ExprInner
				| (PositiveExpr) ExprInner
				;
			  			  
ExprInner ::= (AddExpr) Expr:te Addop Term:t
		 		| (TermExpr) Term:t
		 		;

Term ::= (FactSingle) Factor:t
				| (FactExpr) Term:te Mulop Factor:t
				;

Factor ::= (ConstNum) NUMBER
				| (ConstChar) CHAR
				| (ConstBool) BOOL
				| (Var) Designator:d
		    	| (FuncCall) Designator:func LPAREN ActualPars RPAREN
		    	| LPAREN Expr RPAREN
		    	| NEW Type:t LSQUAREBR Expr RSQUAREBR
		    	| NEW Type:t LPAREN ActualPars RPAREN
		   		;

ActualPars ::= (Actuals) ActualParamList 
				| (NoActuals) /* epsilon */ 
			   	;
			   
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
				| (ActualParam) Expr
				;

Addop ::= (Addop) PLUS 
				| (Minusop) MINUS
				;
				
Mulop ::= (Mulop) STAR 
				| (Divop) FWDSLASH
				| (Percop) PERC
				;
